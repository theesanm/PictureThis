const express = require('express');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const { authenticateToken } = require('../middleware/auth');
const { query } = require('../utils/database');

const router = express.Router();

// Get user's gallery (all images generated by the user)
router.get('/gallery', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    
    const result = await query(
      'SELECT id, prompt, image_url, created_at, generation_cost FROM images WHERE user_id = $1 ORDER BY created_at DESC',
      [userId]
    );
    
    const images = result.rows.map(row => ({
      id: row.id,
      prompt: row.prompt,
      imageUrl: row.image_url,
      createdAt: row.created_at,
      generationCost: row.generation_cost
    }));
    
    res.json({
      success: true,
      images: images,
      total: images.length
    });
  } catch (error) {
    console.error('Error fetching user gallery:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching gallery images'
    });
  }
});

// Configure multer for file uploads
const storage = multer.memoryStorage();
const upload = multer({
  storage: storage,
  limits: {
    fileSize: parseInt(process.env.MAX_FILE_SIZE) || 10485760 // 10MB default
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'));
    }
  }
});

// Generate image using Google Gemini via OpenRouter
async function generateImageWithGemini(prompt, uploadedImages = []) {
  const startTime = Date.now();
  
  try {
    console.log(`Generating image with Gemini (${uploadedImages.length} reference images)...`);
    console.log(`Prompt: "${prompt}"`);
    
    // Determine which API structure to use based on whether images are provided
    let requestBody;
    
    if (uploadedImages.length > 0) {
      // Use image-enhanced generation with max 2 images
      const content = [
        {
          "type": "text",
          "text": prompt
        }
      ];
      
      // Add uploaded images (max 2)
      uploadedImages.slice(0, 2).forEach(imageUrl => {
        content.push({
          "type": "image_url",
          "image_url": {
            "url": imageUrl
          }
        });
      });
      
      requestBody = {
        "model": process.env.OPENROUTER_GEMINI_MODEL,
        "messages": [
          {
            "role": "user",
            "content": content
          }
        ],
        "generation_config": {
          "numberOfImages": 1,
          "negativePrompt": "cartoon, drawing, watermark",
          "seed": 71,
          "aspectRatio": "16:9",
          "style": "photorealistic",
          "sampleImageSize": "2K"
        }
      };
    } else {
      // Use text-only generation
      requestBody = {
        "model": process.env.OPENROUTER_GEMINI_MODEL,
        "messages": [
          {
            "role": "user",
            "content": [
              {
                "type": "text",
                "text": prompt
              }
            ]
          }
        ],
        "generation_config": {
          "numberOfImages": 1,
          "negativePrompt": "cartoon, drawing, watermark",
          "seed": 8,
          "aspectRatio": "16:9",
          "style": "3D render",
          "sampleImageSize": "2K"
        }
      };
    }

    console.log('Request body:', JSON.stringify(requestBody, null, 2));

    const response = await fetch(`${process.env.OPENROUTER_API_URL}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': process.env.OPENROUTER_APP_URL || 'http://localhost:3011',
        'X-Title': 'PictureThis App'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('OpenRouter API error response:', errorText);
      throw new Error(`OpenRouter API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const elapsed = Date.now() - startTime;
    
    console.log(`Gemini image generation completed in ${elapsed}ms`);
    console.log('OpenRouter Response:', JSON.stringify(data, null, 2));

    // Extract image from response based on actual Gemini response format
    if (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.images) {
      const images = data.choices[0].message.images;
      
      if (images.length > 0 && images[0].image_url && images[0].image_url.url) {
        const dataUrl = images[0].image_url.url;
        
        // Check if it's a base64 data URL
        if (dataUrl.startsWith('data:image/png;base64,')) {
          // Extract base64 data
          const base64Data = dataUrl.replace('data:image/png;base64,', '');
          
          // Create filename
          const filename = `generated_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.png`;
          const filepath = path.join(__dirname, '../../uploads', filename);
          
          // Ensure uploads directory exists
          const fs = require('fs');
          const uploadsDir = path.join(__dirname, '../../uploads');
          if (!fs.existsSync(uploadsDir)) {
            fs.mkdirSync(uploadsDir, { recursive: true });
          }
          
          // Convert base64 to buffer and save as PNG file
          const imageBuffer = Buffer.from(base64Data, 'base64');
          fs.writeFileSync(filepath, imageBuffer);
          
          // Return the public URL for the saved image
          return `http://localhost:3011/uploads/${filename}`;
        } else if (dataUrl.startsWith('http')) {
          // If it's already a URL, return it directly
          return dataUrl;
        } else {
          throw new Error('Unexpected image URL format');
        }
      } else {
        throw new Error('No images found in response');
      }
    } else {
      console.warn('Unexpected response format from Gemini:', JSON.stringify(data, null, 2));
      throw new Error('Invalid response format from Gemini API');
    }

    // Extract image from response - Gemini returns base64 data in images array
    if (data.choices && data.choices[0] && data.choices[0].message) {
      const message = data.choices[0].message;
      
      // Check if images array exists in the message
      if (message.images && Array.isArray(message.images) && message.images.length > 0) {
        const imageObj = message.images[0];
        
        if (imageObj.type === "image_url" && imageObj.image_url && imageObj.image_url.url) {
          const imageUrl = imageObj.image_url.url;
          
          // Check if it's a base64 data URL
          if (imageUrl.startsWith('data:image/')) {
            // Convert base64 to proper image file and save it
            const base64Data = imageUrl.split(',')[1]; // Remove data:image/png;base64, prefix
            const imageBuffer = Buffer.from(base64Data, 'base64');
            
            // Generate unique filename
            const timestamp = Date.now();
            const randomId = Math.random().toString(36).substring(2);
            const filename = `gemini_${timestamp}_${randomId}.png`;
            const imagePath = `./uploads/${filename}`;
            
            // Ensure uploads directory exists
            const fs = require('fs');
            const path = require('path');
            const uploadsDir = path.dirname(imagePath);
            if (!fs.existsSync(uploadsDir)) {
              fs.mkdirSync(uploadsDir, { recursive: true });
            }
            
            // Save the image file
            fs.writeFileSync(imagePath, imageBuffer);
            
            // Return URL that points to the saved file
            const imageUrl = `http://localhost:3011/uploads/${filename}`;
            console.log(`Image saved to: ${imagePath}, accessible at: ${imageUrl}`);
            return imageUrl;
          } else {
            // It's already a URL, return as is
            return imageUrl;
          }
        }
      }
      
      console.warn('Unexpected response format from Gemini - no images found:', JSON.stringify(message, null, 2));
      throw new Error('No image found in Gemini response');
    } else {
      throw new Error('Invalid response format from Gemini API');
    }

  } catch (error) {
    console.error('Gemini image generation failed:', error);
    throw error;
  }
}

// Generate image (placeholder - integrate with AI API later)
router.post('/generate', authenticateToken, upload.fields([
  { name: 'image1', maxCount: 1 },
  { name: 'image2', maxCount: 1 }
]), async (req, res) => {
  try {
    const { prompt, userId, hasUsagePermission } = req.body;
    const files = req.files;
    const currentUserId = req.user.userId;

    console.log('Generate request:', { 
      prompt, 
      userId, 
      hasPermission: hasUsagePermission,
      files: files ? Object.keys(files) : 'none' 
    });

    if (!prompt || prompt.trim().length === 0) {
      // Check if at least one image is provided when no prompt
      if (!files || Object.keys(files).length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Prompt or at least one image is required'
        });
      }
    }
    
    // If images are provided, require permission confirmation
    if (files && Object.keys(files).length > 0 && hasUsagePermission !== 'true') {
      return res.status(400).json({
        success: false,
        message: 'You must confirm that you have permission to use these images'
      });
    }

    // Get credit cost from request or settings
    let creditCost = req.body.creditCost ? parseInt(req.body.creditCost) : null;
    
    // If not provided in the request, get from settings
    if (!creditCost) {
      const settingsResult = await query('SELECT credit_cost_per_image FROM settings LIMIT 1');
      creditCost = settingsResult.rows.length > 0 ? parseInt(settingsResult.rows[0].credit_cost_per_image) : 10;
    }
    
    // Check user credits
    const userResult = await query('SELECT credits FROM users WHERE id = $1', [currentUserId]);
    const userCredits = parseInt(userResult.rows[0]?.credits) || 0;
    
    if (userCredits < creditCost) {
      return res.status(403).json({
        success: false,
        message: `Insufficient credits. You need ${creditCost} credits to generate an image.`,
        data: {
          available: userCredits,
          required: creditCost
        }
      });
    }

    // TODO: Integrate with AI image generation API (OpenAI DALL-E, Stable Diffusion, etc.)
    // For now, return a placeholder response with uploaded images info

    let imageInfo = '';
    let uploadedImages = [];
    
    if (files) {
      const uploadedFiles = Object.keys(files).map(key => files[key][0]);
      imageInfo = ` with ${uploadedFiles.length} reference image(s)`;
      
      // Convert uploaded images to base64 data URLs for API
      for (const file of uploadedFiles) {
        const base64 = file.buffer.toString('base64');
        const mimeType = file.mimetype;
        const dataUrl = `data:${mimeType};base64,${base64}`;
        uploadedImages.push(dataUrl);
      }
    }

    // Call Google Gemini model via OpenRouter for image generation
    let generatedImageUrl;
    try {
      generatedImageUrl = await generateImageWithGemini(prompt, uploadedImages);
    } catch (error) {
      console.error('Image generation failed:', error);
      // Return error response without deducting credits or saving to database
      return res.status(500).json({
        success: false,
        message: 'Failed to generate image. Please try again later.'
      });
    }

    // Save image record
    const hasPermission = hasUsagePermission === 'true';
    const imageResult = await query(
      'INSERT INTO images (user_id, prompt, image_url, generation_cost, has_usage_permission, usage_confirmed_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *',
      [
        currentUserId, 
        prompt || 'Image-based generation', 
        generatedImageUrl, 
        creditCost, 
        hasPermission, 
        hasPermission ? new Date() : null
      ]
    );
    
    // Deduct credits from user
    await query(
      'UPDATE users SET credits = credits - $1 WHERE id = $2',
      [creditCost, currentUserId]
    );
    
    // Record the credit transaction
    await query(
      'INSERT INTO credit_transactions (user_id, amount, transaction_type, description) VALUES ($1, $2, $3, $4)',
      [currentUserId, -creditCost, 'usage', 'Image generation']
    );
    
    // If user confirmed permissions, record this in the user_permissions table
    if (hasPermission && files && Object.keys(files).length > 0) {
      try {
        // Get IP address and user agent
        const ipAddress = req.headers['x-forwarded-for'] || req.connection.remoteAddress;
        const userAgent = req.headers['user-agent'];
        
        // Check if we already have a record for this user
        const existingPermission = await query(
          'SELECT * FROM user_permissions WHERE user_id = $1 AND permission_type = $2',
          [currentUserId, 'image_usage']
        );
        
        if (existingPermission.rows.length === 0) {
          // Insert new permission acceptance record
          await query(
            'INSERT INTO user_permissions (user_id, permission_type, accepted, ip_address, user_agent) VALUES ($1, $2, $3, $4, $5)',
            [currentUserId, 'image_usage', true, ipAddress, userAgent]
          );
        } else {
          // Update existing permission acceptance record
          await query(
            'UPDATE user_permissions SET accepted = $1, acceptance_date = $2, ip_address = $3, user_agent = $4 WHERE user_id = $5 AND permission_type = $6',
            [true, new Date(), ipAddress, userAgent, currentUserId, 'image_usage']
          );
        }
      } catch (permError) {
        console.error('Error recording permission acceptance:', permError);
        // Don't fail the request if this part fails
      }
    }

    res.json({
      success: true,
      message: 'Image generated successfully',
      data: {
        image: imageResult.rows[0],
        uploadedFiles: files ? Object.keys(files).length : 0
      }
    });
  } catch (error) {
    console.error('Image generation error:', error);
    res.status(500).json({
      success: false,
      message: 'Image generation failed'
    });
  }
});

// Get user's images
router.get('/my-images', authenticateToken, async (req, res) => {
  try {
    const result = await query(
      'SELECT * FROM images WHERE user_id = $1 ORDER BY created_at DESC',
      [req.user.userId]
    );

    res.json({
      success: true,
      data: {
        images: result.rows
      }
    });
  } catch (error) {
    console.error('Fetch images error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch images'
    });
  }
});

// Upload and process image
router.post('/upload', authenticateToken, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No image file provided'
      });
    }

    const { prompt } = req.body;
    const userId = req.user.userId;

    // Save image to database
    const imageResult = await query(
      'INSERT INTO images (user_id, prompt, image_data, file_name, file_size) VALUES ($1, $2, $3, $4, $5) RETURNING *',
      [userId, prompt || '', req.file.buffer, req.file.originalname, req.file.size]
    );

    res.json({
      success: true,
      message: 'Image uploaded successfully',
      data: {
        image: imageResult.rows[0]
      }
    });
  } catch (error) {
    console.error('Image upload error:', error);
    res.status(500).json({
      success: false,
      message: 'Image upload failed'
    });
  }
});

// Download image
router.get('/:id/download', authenticateToken, async (req, res) => {
  try {
    const imageId = req.params.id;
    const userId = req.user.userId;

    const result = await query(
      'SELECT * FROM images WHERE id = $1 AND user_id = $2',
      [imageId, userId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Image not found'
      });
    }

    const image = result.rows[0];

    if (image.image_data) {
      res.setHeader('Content-Type', 'image/jpeg');
      res.setHeader('Content-Disposition', `attachment; filename="${image.file_name || 'generated-image.jpg'}"`);
      res.send(image.image_data);
    } else {
      res.redirect(image.image_url);
    }
  } catch (error) {
    console.error('Image download error:', error);
    res.status(500).json({
      success: false,
      message: 'Image download failed'
    });
  }
});

// Serve uploaded/generated images
router.get('/uploads/:filename', (req, res) => {
  try {
    const filename = req.params.filename;
    const filepath = path.join(__dirname, '../../uploads', filename);
    
    // Check if file exists
    if (!fs.existsSync(filepath)) {
      return res.status(404).json({
        success: false,
        message: 'Image not found'
      });
    }
    
    // Serve the image file
    res.sendFile(filepath);
  } catch (error) {
    console.error('Error serving image:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to serve image'
    });
  }
});

module.exports = router;
